{"ast":null,"code":"const autoBind = require(\"auto-bind\");\n\nconst {\n  completeTransaction\n} = require(\"./utils/general\");\n/**\n * @dev Constant flow agreement v1 helper class\n */\n\n\nmodule.exports = class ConstantFlowAgreementV1Helper {\n  /**\n   * @dev Create new helper class\n   * @param {Framework} sf Superfluid Framework object\n   *\n   * NOTE: You should first call async function Framework.initialize to initialize the object.\n   */\n  constructor(sf) {\n    this._sf = sf;\n    this._cfa = sf.agreements.cfa;\n    autoBind(this);\n  }\n  /**\n   * @dev Create a new flow\n   * @param {tokenParam} superToken superToken for the flow\n   * @param {addressParam} sender sender of the flow\n   * @param {addressParam} receiver receiver of the flow\n   * @param {flowRateParam} flowRate the flowrate of the flow\n   * @param {Buffer} userData the user data passed to the callbacks\n   * @param {Function} onTransaction function to be called when transaction hash has been generated\n   * @return {Promise<Transaction>} web3 transaction object\n   */\n\n\n  async createFlow(_ref) {\n    let {\n      superToken,\n      sender,\n      receiver,\n      flowRate,\n      userData,\n      onTransaction = () => null\n    } = _ref;\n    const superTokenNorm = await this._sf.utils.normalizeTokenParam(superToken);\n    const senderNorm = await this._sf.utils.normalizeAddressParam(sender);\n    const receiverNorm = await this._sf.utils.normalizeAddressParam(receiver);\n\n    const flowRateNorm = this._sf.utils.normalizeFlowRateParam(flowRate);\n\n    userData = userData || \"0x\";\n    console.debug(`Create flow from ${sender} to ${receiver} at ${flowRate} ...`);\n    const tx = await completeTransaction({\n      sf: this._sf,\n      args: [this._cfa.address, this._cfa.contract.methods.createFlow(superTokenNorm, receiverNorm, flowRateNorm, \"0x\").encodeABI(), userData],\n      sender: senderNorm,\n      method: this._sf.host.callAgreement,\n      onTransaction\n    });\n\n    this._sf._pushTxForGasReport(tx, \"createFlow\");\n\n    console.debug(\"Flow created.\");\n    return tx;\n  }\n  /**\n   * @dev Update a new flow with a new flow rate\n   * @param {tokenParam} superToken superToken for the flow\n   * @param {addressParam} sender sender of the flow\n   * @param {addressParam} receiver receiver of the flow\n   * @param {flowRateParam} flowRate the flowrate of the flow\n   * @param {Buffer} userData the user data passed to the callbacks\n   * @param {Function} onTransaction function to be called when transaction hash has been generated\n   * @return {Promise<Transaction>} web3 transaction object\n   */\n\n\n  async updateFlow(_ref2) {\n    let {\n      superToken,\n      sender,\n      receiver,\n      flowRate,\n      userData,\n      onTransaction = () => null\n    } = _ref2;\n    const superTokenNorm = await this._sf.utils.normalizeTokenParam(superToken);\n    const senderNorm = await this._sf.utils.normalizeAddressParam(sender);\n    const receiverNorm = await this._sf.utils.normalizeAddressParam(receiver);\n\n    const flowRateNorm = this._sf.utils.normalizeFlowRateParam(flowRate);\n\n    userData = userData || \"0x\";\n    console.debug(`Update flow from ${sender} to ${receiver} to ${flowRate} ...`);\n    const tx = await completeTransaction({\n      sf: this._sf,\n      args: [this._cfa.address, this._cfa.contract.methods.updateFlow(superTokenNorm, receiverNorm, flowRateNorm, \"0x\").encodeABI(), userData],\n      sender: senderNorm,\n      method: this._sf.host.callAgreement,\n      onTransaction\n    });\n\n    this._sf._pushTxForGasReport(tx, \"updateFlow\");\n\n    console.debug(\"Flow updated.\");\n    return tx;\n  }\n  /**\n   * @dev Delete a existing flow\n   * @param {tokenParam} superToken superToken for the flow\n   * @param {addressParam} sender sender of the flow\n   * @param {addressParam} receiver receiver of the flow\n   * @param {addressParam} by delete flow by a third party (liquidations)\n   * @param {Buffer} userData the user data passed to the callbacks\n   * @param {Function} onTransaction function to be called when transaction hash has been generated\n   * @return {Promise<Transaction>} web3 transaction object\n   */\n\n\n  async deleteFlow(_ref3) {\n    let {\n      superToken,\n      sender,\n      receiver,\n      by,\n      userData,\n      onTransaction = () => null\n    } = _ref3;\n    const superTokenNorm = await this._sf.utils.normalizeTokenParam(superToken);\n    const senderNorm = await this._sf.utils.normalizeAddressParam(sender);\n    const receiverNorm = await this._sf.utils.normalizeAddressParam(receiver);\n    const byNorm = by && (await this._sf.utils.normalizeAddressParam(by)) || senderNorm;\n    userData = userData || \"0x\";\n    console.debug(`Delete flow from ${sender} to ${receiver} by ${by || byNorm} ...`);\n    const tx = await completeTransaction({\n      sf: this._sf,\n      args: [this._cfa.address, this._cfa.contract.methods.deleteFlow(superTokenNorm, senderNorm, receiverNorm, \"0x\").encodeABI(), userData],\n      sender: byNorm,\n      method: this._sf.host.callAgreement,\n      onTransaction\n    });\n\n    this._sf._pushTxForGasReport(tx, \"deleteFlow\");\n\n    console.debug(\"Flow deleted.\");\n    return tx;\n  }\n  /**\n   * @dev Get information of a existing flow\n   * @param {tokenParam} superToken superToken for the flow\n   * @param {addressParam} sender sender of the flow\n   * @param {addressParam} receiver receiver of the flow\n   * @return {Promise<object>} Informationo about the flow:\n   *         - <Date> timestamp, time when the flow was last updated\n   *         - <string> flowRate, flow rate of the flow\n   *         - <string> deposit, deposit of the flow\n   *         - <string> owedDeposit, owed deposit of the flow\n   */\n\n\n  async getFlow(_ref4) {\n    let {\n      superToken,\n      sender,\n      receiver //unit\n\n    } = _ref4;\n    const superTokenNorm = await this._sf.utils.normalizeTokenParam(superToken);\n    const senderNorm = await this._sf.utils.normalizeAddressParam(sender);\n    const receiverNorm = await this._sf.utils.normalizeAddressParam(receiver);\n    const result = await this._cfa.getFlow(superTokenNorm, senderNorm, receiverNorm);\n    return this.constructor._sanitizeflowInfo(result);\n  }\n  /**\n   * @dev Get information of the net flow of an account\n   * @param {tokenParam} superToken superToken for the flow\n   * @param {addressParam} account the account for the query\n   * @return {Promise<string>} Net flow rate of the account\n   */\n\n\n  async getNetFlow(_ref5) {\n    let {\n      superToken,\n      account //unit\n\n    } = _ref5;\n    const superTokenNorm = await this._sf.utils.normalizeTokenParam(superToken);\n    const accountNorm = await this._sf.utils.normalizeAddressParam(account);\n    const netFlow = await this._cfa.getNetFlow(superTokenNorm, accountNorm);\n    return netFlow.toString();\n  }\n  /**\n   * @dev Get information of the net flow of an account\n   * @param {tokenParam} superToken superToken for the flow\n   * @param {addressParam} account the account for the query\n   * @return {Promise<string>} Net flow rate of the account\n   */\n\n\n  async getAccountFlowInfo(_ref6) {\n    let {\n      superToken,\n      account //unit\n\n    } = _ref6;\n    const superTokenNorm = await this._sf.utils.normalizeTokenParam(superToken);\n    const accountNorm = await this._sf.utils.normalizeAddressParam(account);\n    const result = await this._cfa.getAccountFlowInfo(superTokenNorm, accountNorm);\n    return this.constructor._sanitizeflowInfo(result);\n  }\n\n  static _sanitizeflowInfo(_ref7) {\n    let {\n      timestamp,\n      flowRate,\n      deposit,\n      owedDeposit\n    } = _ref7;\n    return {\n      timestamp: new Date(Number(timestamp.toString()) * 1000),\n      flowRate: flowRate.toString(),\n      deposit: deposit.toString(),\n      owedDeposit: owedDeposit.toString()\n    };\n  }\n\n  async getFlowEvents(_ref8) {\n    let {\n      token,\n      receiver = null,\n      sender = null\n    } = _ref8;\n    let flows;\n\n    if (this._cfa.getPastEvents) {\n      flows = await this._cfa.getPastEvents(\"FlowUpdated\", {\n        fromBlock: 0,\n        toBlock: \"latest\",\n        filter: {\n          token,\n          receiver,\n          sender\n        }\n      });\n    } else {\n      const filter = this._cfa.filters.FlowUpdated(token, sender, receiver);\n\n      flows = await this._cfa.queryFilter(filter);\n    }\n\n    return Object.values(flows.reduce((acc, i) => {\n      acc[i.args.sender + \":\" + i.args.receiver] = i;\n      return acc;\n    }, {})).filter(i => i.args.flowRate.toString() != \"0\");\n  }\n  /**\n   * @dev List flows of the account\n   * @param {tokenParam} superToken superToken for the flow\n   * @param {addressParam} account the account for the query\n   * @return {Promise<[]>}\n   */\n\n\n  async listFlows(_ref9) {\n    let {\n      superToken,\n      account,\n      onlyInFlows,\n      onlyOutFlows //unit\n\n    } = _ref9;\n    const superTokenNorm = await this._sf.utils.normalizeTokenParam(superToken);\n    const accountNorm = await this._sf.utils.normalizeAddressParam(account);\n    const result = {};\n\n    if (!onlyOutFlows) {\n      result.inFlows = (await this.getFlowEvents({\n        receiver: accountNorm,\n        token: superTokenNorm\n      })).map(f => ({\n        sender: f.args.sender,\n        receiver: f.args.receiver,\n        flowRate: f.args.flowRate.toString()\n      }));\n    }\n\n    if (!onlyInFlows) {\n      result.outFlows = (await this.getFlowEvents({\n        token: superTokenNorm,\n        sender: accountNorm\n      })).map(f => ({\n        sender: f.args.sender,\n        receiver: f.args.receiver,\n        flowRate: f.args.flowRate.toString()\n      }));\n    }\n\n    return result;\n  }\n\n};","map":null,"metadata":{},"sourceType":"script"}