{"ast":null,"code":"const {\n  getErrorResponse,\n  getMissingArgumentError,\n  getBatchCallHelpText\n} = require(\"./utils/error\");\n\nconst {\n  AbiCoder\n} = require(\"@ethersproject/abi\");\n\nconst abiCoder = new AbiCoder();\nconst OPERATION_TYPES = {\n  ERC20_APPROVE: 1,\n  ERC20_TRANSFER_FROM: 2,\n  SUPERTOKEN_UPGRADE: 101,\n  SUPERTOKEN_DOWNGRADE: 102,\n  SUPERFLUID_CALL_AGREEMENT: 201,\n  CALL_APP_ACTION: 202\n};\nconst AGREEMENT_TYPES = {\n  CFA: \"cfa\",\n  IDA: \"ida\"\n};\n\nconst parseERC20Operation = _ref => {\n  let {\n    index,\n    operationType,\n    data\n  } = _ref;\n  const {\n    token,\n    spender,\n    sender,\n    recipient,\n    amount\n  } = data;\n  if (!amount) throw new Error(getMissingArgumentError(\"amount\", getBatchCallHelpText(index)));\n  if (!token) throw new Error(getMissingArgumentError(\"token\", getBatchCallHelpText(index)));\n  /**\n   * @dev ERC20.approve batch operation type\n   * Call spec:\n   * ISuperToken(target).operationApprove(\n   *     abi.decode(data, (address spender, uint256 amount))\n   * )\n   */\n\n  if (operationType === OPERATION_TYPES.ERC20_APPROVE) {\n    if (!spender) throw new Error(getMissingArgumentError(\"spender\", getBatchCallHelpText(index)));\n    return [operationType, token, abiCoder.encode([\"address\", \"uint256\"], [spender, amount])];\n  }\n  /**\n   * @dev ERC20.transferFrom batch operation type\n   * Call spec:\n   * ISuperToken(target).operationTransferFrom(\n   *     abi.decode(data, (address sender, address recipient, uint256 amount)\n   * )\n   */\n\n\n  if (!sender) throw new Error(getMissingArgumentError(\"sender\", getBatchCallHelpText(index)));\n  return [operationType, token, abiCoder.encode([\"address\", \"address\", \"uint256\"], [sender, recipient, amount])];\n};\n\nconst parseSuperTokenOperation = _ref2 => {\n  let {\n    index,\n    operationType,\n    data\n  } = _ref2;\n  const {\n    amount,\n    token\n  } = data;\n  if (!amount) throw new Error(getMissingArgumentError(\"amount\", getBatchCallHelpText(index)));\n  if (!token) throw new Error(getMissingArgumentError(\"token\", getBatchCallHelpText(index)));\n  /**\n   * @dev SuperToken.upgrade batch operation type\n   * Call spec:\n   * ISuperToken(target).operationUpgrade(\n   *     abi.decode(data, (uint256 amount)\n   * )\n   */\n\n  /**\n   * @dev SuperToken.downgrade batch operation type\n   * Call spec:\n   * ISuperToken(target).operationDowngrade(\n   *     abi.decode(data, (uint256 amount)\n   * )\n   */\n\n  return [operationType, token, abiCoder.encode([\"uint256\"], [amount])];\n};\n\nconst parseSuperFluidOperation = _ref3 => {\n  let {\n    index,\n    operationType,\n    data\n  } = _ref3;\n  const {\n    superApp,\n    agreementType,\n    method,\n    arguments: args,\n    userData = \"0x\",\n    callData\n  } = data;\n  /**\n   * @dev Superfluid.callAgreement batch operation type\n   * Call spec:\n   * callAgreement(\n   *     ISuperAgreement(target)),\n   *     abi.decode(data, (bytes calldata, bytes userdata)\n   * )\n   */\n\n  if (operationType === OPERATION_TYPES.SUPERFLUID_CALL_AGREEMENT) {\n    if (!agreementType) throw new Error(getMissingArgumentError(\"agreementType\", getBatchCallHelpText(index)));\n    if (!method) throw new Error(getMissingArgumentError(\"method\", getBatchCallHelpText(index)));\n    if (!args) throw new Error(getMissingArgumentError(\"arguments\", getBatchCallHelpText(index)));\n    if (!Object.keys(AGREEMENT_TYPES).includes(agreementType)) throw new Error(`You provided an invalid agreementType${getBatchCallHelpText(index)}`);\n    const agreementAddress = this.agreements[AGREEMENT_TYPES[agreementType]].address;\n    const callData = this.agreements[AGREEMENT_TYPES[agreementType]].contract.methods[method](...args).encodeABI();\n    return [operationType, agreementAddress, abiCoder.encode([\"bytes\", \"bytes\"], [callData, userData])];\n  }\n  /**\n   * @dev Superfluid.callAppAction batch operation type\n   * Call spec:\n   * callAppAction(\n   *     ISuperApp(target)),\n   *     data\n   * )\n   */\n\n\n  if (!superApp) throw new Error(getMissingArgumentError(\"superApp\", getBatchCallHelpText(index)));\n  if (!callData) throw new Error(getMissingArgumentError(\"callData\", getBatchCallHelpText(index)));\n  return [operationType, superApp, callData];\n};\n\nconst parse = _ref4 => {\n  let {\n    index,\n    type,\n    data\n  } = _ref4;\n\n  try {\n    if (!type) throw new Error(getMissingArgumentError(\"type\", getBatchCallHelpText(index)));\n    if (!data) throw new Error(getMissingArgumentError(\"data\", getBatchCallHelpText(index))); // Opertation type\n\n    let operationType = type;\n\n    if (typeof type !== Number) {\n      if (!Object.keys(OPERATION_TYPES).includes(type)) throw new Error(`You provided an invalid operation type \"${type}\"${getBatchCallHelpText(index)}`);\n      operationType = OPERATION_TYPES[type];\n    }\n\n    if ([OPERATION_TYPES.ERC20_APPROVE, OPERATION_TYPES.ERC20_TRANSFER_FROM].includes(operationType)) return parseERC20Operation({\n      index,\n      operationType,\n      data\n    });\n    if ([OPERATION_TYPES.SUPERTOKEN_UPGRADE, OPERATION_TYPES.SUPERTOKEN_DOWNGRADE].includes(operationType)) return parseSuperTokenOperation({\n      index,\n      operationType,\n      data\n    });\n    if ([OPERATION_TYPES.SUPERFLUID_CALL_AGREEMENT, OPERATION_TYPES.CALL_APP_ACTION].includes(operationType)) return parseSuperFluidOperation({\n      index,\n      operationType,\n      data\n    });\n    throw new Error(`You provided an invalid operation type \"${type}\"${getBatchCallHelpText(index)}`);\n  } catch (e) {\n    throw new Error(getErrorResponse(e, \"batchCall\"));\n  }\n};\n\nconst batchCall = _ref5 => {\n  let {\n    agreements,\n    calls\n  } = _ref5;\n  if (!calls || !Array.isArray(calls)) throw new Error(getErrorResponse(\"You must provide an array of calls\", \"batchCall\"));\n  this.agreements = agreements;\n  return calls.map((call, index) => parse({\n    index,\n    ...call\n  }));\n};\n\nmodule.exports = {\n  batchCall\n};","map":null,"metadata":{},"sourceType":"script"}