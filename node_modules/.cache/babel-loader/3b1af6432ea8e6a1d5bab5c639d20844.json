{"ast":null,"code":"import { convertFromNext, convertToNext } from '../check/arbitrary/definition/Converters.js';\nimport { integer } from './integer.js';\nimport { nat } from './nat.js';\nimport { set } from './set.js';\nimport { tuple } from './tuple.js';\nimport { maxLengthFromMinLength } from './_internals/helpers/MaxLengthFromMinLength.js';\n\nfunction extractMaxIndex(indexesAndValues) {\n  let maxIndex = -1;\n\n  for (let index = 0; index !== indexesAndValues.length; ++index) {\n    maxIndex = Math.max(maxIndex, indexesAndValues[index][0]);\n  }\n\n  return maxIndex;\n}\n\nfunction arrayFromItems(length, indexesAndValues) {\n  const array = Array(length);\n\n  for (let index = 0; index !== indexesAndValues.length; ++index) {\n    const it = indexesAndValues[index];\n    if (it[0] < length) array[it[0]] = it[1];\n  }\n\n  return array;\n}\n\nexport function sparseArray(arb) {\n  let constraints = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    minNumElements = 0,\n    maxNumElements = maxLengthFromMinLength(minNumElements),\n    maxLength = Math.min(maxLengthFromMinLength(maxNumElements), 4294967295),\n    noTrailingHole\n  } = constraints;\n\n  if (minNumElements > maxLength) {\n    throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal length of the array`);\n  }\n\n  if (minNumElements > maxNumElements) {\n    throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal number of non-holes`);\n  }\n\n  const resultedMaxNumElements = Math.min(maxNumElements, maxLength);\n  const maxIndexAuthorized = Math.max(maxLength - 1, 0);\n  const sparseArrayNoTrailingHole = convertFromNext(convertToNext(set(tuple(nat(maxIndexAuthorized), arb), {\n    minLength: minNumElements,\n    maxLength: resultedMaxNumElements,\n    compare: (itemA, itemB) => itemA[0] === itemB[0]\n  })).map(items => {\n    const lastIndex = extractMaxIndex(items);\n    return arrayFromItems(lastIndex + 1, items);\n  }, value => {\n    if (!Array.isArray(value)) {\n      throw new Error('Not supported entry type');\n    }\n\n    return Object.entries(value).map(entry => [Number(entry[0]), entry[1]]);\n  }));\n\n  if (noTrailingHole || maxLength === minNumElements) {\n    return sparseArrayNoTrailingHole;\n  }\n\n  return convertFromNext(convertToNext(tuple(sparseArrayNoTrailingHole, integer({\n    min: minNumElements,\n    max: maxLength\n  }))).map(data => {\n    const sparse = data[0];\n    const targetLength = data[1];\n\n    if (sparse.length >= targetLength) {\n      return sparse;\n    }\n\n    const longerSparse = sparse.slice();\n    longerSparse.length = targetLength;\n    return longerSparse;\n  }, value => {\n    if (!Array.isArray(value)) {\n      throw new Error('Not supported entry type');\n    }\n\n    return [value, value.length];\n  }));\n}","map":null,"metadata":{},"sourceType":"module"}