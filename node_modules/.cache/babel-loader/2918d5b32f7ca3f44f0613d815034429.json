{"ast":null,"code":"const ansiRegex = require('ansi-regex');\n\nconst superSplit = require('super-split');\n\nconst arrayUniq = require('array-uniq');\n\nconst stripAnsi = require('strip-ansi');\n\nconst realignOutOfBoundsCoords = (text, opts) => {\n  const plain = stripAnsi(text);\n  const lines = plain.split('\\n');\n  const totalLines = lines.length; // 'End.line marker out of bounds (max).'\n\n  if (opts.end.line > totalLines) {\n    opts.end.line = totalLines;\n  } // 'Start.line marker out of bounds (min).'\n\n\n  if (opts.start.line < 1) {\n    opts.start.line = 1;\n  } // 'Start.column marker out of bounds (min).'\n\n\n  if (opts.start.column < 1) {\n    opts.start.column = 1;\n  } // 'End.column marker out of bounds (max).'\n\n\n  if (opts.end.column > lines[opts.end.line - 1].length) {\n    opts.end.column = lines[opts.end.line - 1].length;\n  }\n\n  if (opts.start.line > opts.end.line) {\n    throw new Error('Your start line is after your end line.');\n  }\n\n  if (opts.start.line === opts.end.line && opts.end.column < opts.start.column) {\n    throw new Error('Your end column is after your start column.');\n  }\n\n  return false;\n}; // Returns arys:\n// 1 - ANSI Escape sequences from section\n// 2 - Glyphs in section (ansi escape seq - or - ascii character)\n\n\nconst atomize = section => {\n  const ansies = arrayUniq(section.match(ansiRegex()));\n  const words = superSplit(section, ansies);\n  let glyphs = [];\n  words.forEach(word => {\n    if (ansies.includes(word) === false) {\n      glyphs = glyphs.concat(word.split(''));\n      return;\n    }\n\n    glyphs.push(word);\n  });\n  return {\n    ansies,\n    glyphs\n  };\n};\n\nconst markSection = (section, opts, linear) => {\n  const {\n    ansies,\n    glyphs\n  } = atomize(section);\n  let x = 0;\n  let y = 0;\n  let inPoint;\n  let outPoint;\n  let output = '';\n  const height = opts.end.line - opts.start.line;\n\n  const markNotBegun = () => {\n    return typeof inPoint !== 'number' && typeof outPoint !== 'number';\n  };\n\n  const markHasEnded = () => {\n    return typeof inPoint === 'number' && typeof outPoint === 'number';\n  };\n\n  const outsideOfMark = () => {\n    return markNotBegun() || markHasEnded();\n  };\n\n  glyphs.forEach(glyph => {\n    if (ansies.includes(glyph) === false) {\n      if (glyph === '\\n' && !linear) {\n        y += 1;\n        x = -1;\n      }\n\n      x += 1;\n\n      if (x === opts.start.column && y === 0) {\n        inPoint = output.length;\n      }\n\n      output += glyph;\n\n      if (x === opts.end.column && y === height) {\n        outPoint = output.length;\n      }\n\n      return;\n    }\n\n    if (outsideOfMark()) {\n      output += glyph;\n    } else if (!outsideOfMark() && !opts.resetColor) {\n      output += glyph;\n    }\n  });\n  const pre = output.substr(0, inPoint);\n  const mark = opts.color(output.substr(inPoint, outPoint - inPoint));\n  const post = output.substr(outPoint);\n  const sectionMarked = pre + mark + post;\n  return sectionMarked;\n};\n\nconst mark2d = (text, opts) => {\n  realignOutOfBoundsCoords(text, opts);\n  const lines = text.split('\\n'); // Minus 1: because line and column numbers start at 1\n\n  const startLine = opts.start.line - 1;\n  const endLine = opts.end.line - 1; // Plus 1: because slice does not include the end indice\n\n  const unmarkedSection = lines.slice(startLine, endLine + 1).join('\\n');\n  const preSection = lines.slice(0, startLine);\n  const markedSection = markSection(unmarkedSection, opts);\n  const postSection = lines.slice(endLine + 1);\n  const result = preSection.concat([markedSection]).concat(postSection).join('\\n');\n  return result;\n};\n\nconst mark1d = (text, opts, linear) => {\n  const markedSection = markSection(text, opts, linear);\n  return markedSection;\n};\n\nconst mark = (text, opts, linear) => {\n  return linear ? mark1d(text, opts, linear) : mark2d(text, opts);\n};\n\nconst validMarkersNumbers = opts => {\n  return typeof opts.start === 'number' && typeof opts.end === 'number';\n};\n\nconst validMarkersObject = opts => {\n  return typeof opts.start === 'object' && typeof opts.end === 'object' && typeof opts.start.line === 'number' && typeof opts.start.column === 'number' && typeof opts.end.line === 'number' && typeof opts.end.column === 'number';\n};\n\nconst ansiMark = (text, opts) => {\n  if (validMarkersObject(opts)) {\n    return mark(text, opts);\n  }\n\n  if (validMarkersNumbers(opts)) {\n    opts.start = {\n      line: 1,\n      column: opts.start\n    };\n    opts.end = {\n      line: 1,\n      column: opts.end\n    };\n    const linear = true;\n    return mark(text, opts, linear);\n  }\n\n  throw new Error('Invalid marker definition.');\n};\n\nmodule.exports = ansiMark;","map":null,"metadata":{},"sourceType":"script"}