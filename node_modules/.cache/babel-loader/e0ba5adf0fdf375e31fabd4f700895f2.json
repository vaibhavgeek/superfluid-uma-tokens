{"ast":null,"code":"function readBh(value) {\n  if (value.length === 0) return [];else return value.split(':');\n}\n\nfunction extractEhAndL(value) {\n  const valueSplits = value.split(':');\n\n  if (valueSplits.length >= 2 && valueSplits[valueSplits.length - 1].length <= 4) {\n    return [valueSplits.slice(0, valueSplits.length - 2), `${valueSplits[valueSplits.length - 2]}:${valueSplits[valueSplits.length - 1]}`];\n  }\n\n  return [valueSplits.slice(0, valueSplits.length - 1), valueSplits[valueSplits.length - 1]];\n}\n\nexport function fullySpecifiedMapper(data) {\n  return `${data[0].join(':')}:${data[1]}`;\n}\nexport function fullySpecifiedUnmapper(value) {\n  if (typeof value !== 'string') throw new Error('Invalid type');\n  return extractEhAndL(value);\n}\nexport function onlyTrailingMapper(data) {\n  return `::${data[0].join(':')}:${data[1]}`;\n}\nexport function onlyTrailingUnmapper(value) {\n  if (typeof value !== 'string') throw new Error('Invalid type');\n  if (!value.startsWith('::')) throw new Error('Invalid value');\n  return extractEhAndL(value.substring(2));\n}\nexport function multiTrailingMapper(data) {\n  return `${data[0].join(':')}::${data[1].join(':')}:${data[2]}`;\n}\nexport function multiTrailingUnmapper(value) {\n  if (typeof value !== 'string') throw new Error('Invalid type');\n  const [bhString, trailingString] = value.split('::', 2);\n  const [eh, l] = extractEhAndL(trailingString);\n  return [readBh(bhString), eh, l];\n}\nexport function multiTrailingMapperOne(data) {\n  return multiTrailingMapper([data[0], [data[1]], data[2]]);\n}\nexport function multiTrailingUnmapperOne(value) {\n  const out = multiTrailingUnmapper(value);\n  return [out[0], out[1].join(':'), out[2]];\n}\nexport function singleTrailingMapper(data) {\n  return `${data[0].join(':')}::${data[1]}`;\n}\nexport function singleTrailingUnmapper(value) {\n  if (typeof value !== 'string') throw new Error('Invalid type');\n  const [bhString, trailing] = value.split('::', 2);\n  return [readBh(bhString), trailing];\n}\nexport function noTrailingMapper(data) {\n  return `${data[0].join(':')}::`;\n}\nexport function noTrailingUnmapper(value) {\n  if (typeof value !== 'string') throw new Error('Invalid type');\n  if (!value.endsWith('::')) throw new Error('Invalid value');\n  return [readBh(value.substring(0, value.length - 2))];\n}","map":null,"metadata":{},"sourceType":"module"}