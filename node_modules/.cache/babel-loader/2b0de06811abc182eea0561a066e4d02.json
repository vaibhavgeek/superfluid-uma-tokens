{"ast":null,"code":"const autoBind = require(\"auto-bind\");\n\nconst {\n  completeTransaction\n} = require(\"./utils/general\");\n/**\n * @dev Instant distribution agreement v1 helper class\n */\n\n\nmodule.exports = class InstantDistributionAgreementV1Helper {\n  /**\n   * @dev Create new helper class\n   * @param {Framework} sf Superfluid Framework object\n   *\n   * NOTE: You should first call async function Framework.initialize to initialize the object.\n   */\n  constructor(sf) {\n    this._sf = sf;\n    this._ida = sf.agreements.ida;\n    autoBind(this);\n  }\n  /**\n   * @dev Create a new index\n   * @param {tokenParam} superToken SuperToken for the index\n   * @param {addressParam} publisher Publisher of the index\n   * @param {int} indexId ID of the index\n   * @param {Function} onTransaction function to be called when transaction hash has been generated\n   * @return {Promise<Transaction>} web3 transaction object\n   */\n\n\n  async createIndex(_ref) {\n    let {\n      superToken,\n      publisher,\n      indexId,\n      userData = \"0x\",\n      onTransaction = () => null\n    } = _ref;\n    const superTokenNorm = await this._sf.utils.normalizeTokenParam(superToken);\n    const publisherNorm = await this._sf.utils.normalizeAddressParam(publisher);\n    const tx = await completeTransaction({\n      sf: this._sf,\n      args: [this._ida.address, this._ida.contract.methods.createIndex(superTokenNorm, indexId, \"0x\").encodeABI(), userData],\n      sender: publisherNorm,\n      method: this._sf.host.callAgreement,\n      onTransaction\n    });\n    console.debug(\"Index created.\");\n    return tx;\n  }\n  /**\n   * @dev Distribute tokens to an index\n   * @param {tokenParam} superToken SuperToken for the index\n   * @param {addressParam} publisher Publisher of the index\n   * @param {int} indexId ID of the index\n   * @param {BN} amount Amount to be distributed\n   * @param {Function} onTransaction function to be called when transaction hash has been generated\n   * @return {Promise<Transaction>} web3 transaction object\n   */\n\n\n  async distribute(_ref2) {\n    let {\n      superToken,\n      publisher,\n      indexId,\n      amount,\n      userData = \"0x\",\n      onTransaction = () => null\n    } = _ref2;\n    const superTokenNorm = await this._sf.utils.normalizeTokenParam(superToken);\n    const publisherNorm = await this._sf.utils.normalizeAddressParam(publisher);\n    const tx = await completeTransaction({\n      sf: this._sf,\n      args: [this._ida.address, this._ida.contract.methods.distribute(superTokenNorm, indexId, amount, \"0x\").encodeABI(), userData],\n      sender: publisherNorm,\n      method: this._sf.host.callAgreement,\n      onTransaction\n    });\n    console.debug(\"Distribution complete.\");\n    return tx;\n  }\n  /**\n   * @dev Update the value of a index\n   * @param {tokenParam} superToken SuperToken for the index\n   * @param {addressParam} publisher Publisher of the index\n   * @param {int} indexId ID of the index\n   * @param {Function} onTransaction function to be called when transaction hash has been generated\n   * @return {Promise<Transaction>} web3 transaction object\n   *\n   * NOTE:\n   * it has the same effect as doing distribute, but closer to the low level data structure\n   * of the index.\n   */\n\n\n  async updateIndex(_ref3) {\n    let {\n      superToken,\n      publisher,\n      indexId,\n      indexValue,\n      userData = \"0x\",\n      onTransaction = () => null\n    } = _ref3;\n    const superTokenNorm = await this._sf.utils.normalizeTokenParam(superToken);\n    const publisherNorm = await this._sf.utils.normalizeAddressParam(publisher);\n    const tx = await completeTransaction({\n      sf: this._sf,\n      args: [this._ida.address, this._ida.contract.methods.updateIndex(superTokenNorm, indexId, indexValue, \"0x\").encodeABI(), userData],\n      sender: publisherNorm,\n      method: this._sf.host.callAgreement,\n      onTransaction\n    });\n    console.debug(\"Index updated.\");\n    return tx;\n  }\n  /**\n   * @dev Update number of units of a subscription by the publisher of the index\n   * @param {tokenParam} superToken SuperToken for the index\n   * @param {addressParam} publisher Publisher of the index\n   * @param {int} indexId ID of the index\n   * @param {addressParam} subscriber Subscriber of the index\n   * @param {BN} units Units of the subscription\n   * @param {Function} onTransaction function to be called when transaction hash has been generated\n   * @return {Promise<Transaction>} web3 transaction object\n   */\n\n\n  async updateSubscription(_ref4) {\n    let {\n      superToken,\n      publisher,\n      indexId,\n      subscriber,\n      units,\n      userData = \"0x\",\n      onTransaction = () => null\n    } = _ref4;\n    const superTokenNorm = await this._sf.utils.normalizeTokenParam(superToken);\n    const publisherNorm = await this._sf.utils.normalizeAddressParam(publisher);\n    const subscriberNorm = await this._sf.utils.normalizeAddressParam(subscriber);\n    const tx = await completeTransaction({\n      sf: this._sf,\n      args: [this._ida.address, this._ida.contract.methods.updateSubscription(superTokenNorm, indexId, subscriberNorm, units, \"0x\").encodeABI(), userData],\n      sender: publisherNorm,\n      method: this._sf.host.callAgreement,\n      onTransaction\n    });\n    console.debug(\"Subscription updated.\");\n    return tx;\n  }\n  /**\n   * @dev Approve the subscription by a subscriber of the index\n   * @param {tokenParam} superToken SuperToken for the index\n   * @param {addressParam} publisher Publisher of the index\n   * @param {int} indexId ID of the index\n   * @param {addressParam} subscriber Subscriber of the index\n   * @param {Function} onTransaction function to be called when transaction hash has been generated\n   * @return {Promise<Transaction>} web3 transaction object\n   *\n   * NOTE:\n   * By approving, the subscriber can use the balance the moment the publishder distributes\n   * tokens without doing the extra claim step.\n   */\n\n\n  async approveSubscription(_ref5) {\n    let {\n      superToken,\n      publisher,\n      indexId,\n      subscriber,\n      userData = \"0x\",\n      onTransaction = () => null\n    } = _ref5;\n    const superTokenNorm = await this._sf.utils.normalizeTokenParam(superToken);\n    const publisherNorm = await this._sf.utils.normalizeAddressParam(publisher);\n    const subscriberNorm = await this._sf.utils.normalizeAddressParam(subscriber);\n    const tx = await completeTransaction({\n      sf: this._sf,\n      args: [this._ida.address, this._ida.contract.methods.approveSubscription(superTokenNorm, publisherNorm, indexId, \"0x\").encodeABI(), userData],\n      sender: subscriberNorm,\n      method: this._sf.host.callAgreement,\n      onTransaction\n    });\n    console.debug(\"Subscription approved.\");\n    return tx;\n  }\n  /**\n   * @dev Revoke the subscription by a subscriber of the index\n   * @param {tokenParam} superToken SuperToken for the index\n   * @param {addressParam} publisher Publisher of the index\n   * @param {int} indexId ID of the index\n   * @param {addressParam} subscriber Subscriber of the index\n   * @param {Function} onTransaction function to be called when transaction hash has been generated\n   * @return {Promise<Transaction>} web3 transaction object\n   *\n   * NOTE:\n   * By revoking, the subscriber will need to do claim step in order to get the tokens.\n   */\n\n\n  async revokeSubscription(_ref6) {\n    let {\n      superToken,\n      indexId,\n      publisher,\n      subscriber,\n      userData = \"0x\",\n      onTransaction = () => null\n    } = _ref6;\n    const superTokenNorm = await this._sf.utils.normalizeTokenParam(superToken);\n    const publisherNorm = await this._sf.utils.normalizeAddressParam(publisher);\n    const subscriberNorm = await this._sf.utils.normalizeAddressParam(subscriber);\n    const tx = await completeTransaction({\n      sf: this._sf,\n      args: [this._ida.address, this._ida.contract.methods.revokeSubscription(superTokenNorm, publisherNorm, indexId, \"0x\").encodeABI(), userData],\n      sender: subscriberNorm,\n      method: this._sf.host.callAgreement,\n      onTransaction\n    });\n    console.debug(\"Subscription revoked.\");\n    return tx;\n  }\n  /**\n   * @dev Delete the subscription by the publisher or a subscriber of the index\n   * @param {tokenParam} superToken SuperToken for the index\n   * @param {addressParam} publisher Publisher of the index\n   * @param {int} indexId ID of the index\n   * @param {addressParam} subscriber Subscriber of the index\n   * @param {addressParam} sender Publisher or subscriber of the index\n   * @param {Function} onTransaction function to be called when transaction hash has been generated\n   * @return {Promise<Transaction>} web3 transaction object\n   *\n   * NOTE:\n   * It means both revoking and clear the units of a subscription.\n   */\n\n\n  async deleteSubscription(_ref7) {\n    let {\n      superToken,\n      indexId,\n      publisher,\n      subscriber,\n      sender,\n      userData = \"0x\",\n      onTransaction = () => null\n    } = _ref7;\n    const superTokenNorm = await this._sf.utils.normalizeTokenParam(superToken);\n    const publisherNorm = await this._sf.utils.normalizeAddressParam(publisher);\n    const subscriberNorm = await this._sf.utils.normalizeAddressParam(subscriber);\n    const senderNorm = await this._sf.utils.normalizeAddressParam(sender);\n    const tx = await completeTransaction({\n      sf: this._sf,\n      args: [this._ida.address, this._ida.contract.methods.deleteSubscription(superTokenNorm, publisherNorm, indexId, subscriberNorm, \"0x\").encodeABI(), userData],\n      sender: senderNorm,\n      method: this._sf.host.callAgreement,\n      onTransaction\n    });\n    console.debug(\"Subscription deleted.\");\n    return tx;\n  }\n  /**\n   * @dev Get details of a subscription\n   * @param {tokenParam} superToken SuperToken for the index\n   * @param {addressParam} publisher Publisher of the index\n   * @param {int} indexId ID of the index\n   * @param {addressParam} subscriber Subscriber of the index\n   * @return {Promise<Subscription>} Subscription data\n   */\n\n\n  async getSubscription(_ref8) {\n    let {\n      superToken,\n      publisher,\n      indexId,\n      subscriber\n    } = _ref8;\n    const superTokenNorm = await this._sf.utils.normalizeTokenParam(superToken);\n    const publisherNorm = await this._sf.utils.normalizeAddressParam(publisher);\n    const subscriberNorm = await this._sf.utils.normalizeAddressParam(subscriber);\n    const result = await this._ida.getSubscription.call(superTokenNorm, publisherNorm, indexId, subscriberNorm);\n    return this.constructor._sanitizeSubscriptionData(result);\n  }\n  /**\n   * @dev Claim distributions to a subscriber of the index by anyone.\n   * @param {tokenParam} superToken SuperToken for the index\n   * @param {addressParam} publisher Publisher of the index\n   * @param {int} indexId ID of the index\n   * @param {addressParam} subscriber Subscriber of the index\n   * @param {addressParam} sender Any account to claim the distribution for the subscriber\n   * @param {Function} onTransaction function to be called when transaction hash has been generated\n   * @return {Promise<Transaction>} web3 transaction object\n   *\n   * NOTE:\n   * If the subscriber has not approved the subscription, anyone can claim the distribution for him.\n   */\n\n\n  async claim(_ref9) {\n    let {\n      superToken,\n      publisher,\n      indexId,\n      subscriber,\n      sender,\n      userData = \"0x\",\n      onTransaction = () => null\n    } = _ref9;\n    const superTokenNorm = await this._sf.utils.normalizeTokenParam(superToken);\n    const publisherNorm = await this._sf.utils.normalizeAddressParam(publisher);\n    const subscriberNorm = await this._sf.utils.normalizeAddressParam(subscriber);\n    const senderNorm = await this._sf.utils.normalizeAddressParam(sender);\n    const tx = await completeTransaction({\n      sf: this._sf,\n      args: [this._ida.address, this._ida.contract.methods.claim(superTokenNorm, publisherNorm, indexId, subscriberNorm, \"0x\").encodeABI(), userData],\n      sender: senderNorm,\n      method: this._sf.host.callAgreement,\n      onTransaction\n    });\n    console.debug(\"Claim complete.\");\n    return tx;\n  }\n  /**\n   * @dev Get details of an index\n   * @param {tokenParam} superToken SuperToken for the index\n   * @param {addressParam} publisher Publisher of the index\n   * @param {int} indexId ID of the index\n   * @return {Promise<Subscription>} Subscription data\n   */\n\n\n  async getIndex(_ref10) {\n    let {\n      superToken,\n      publisher,\n      indexId\n    } = _ref10;\n    const superTokenNorm = await this._sf.utils.normalizeTokenParam(superToken);\n    const publisherNorm = await this._sf.utils.normalizeAddressParam(publisher);\n    const result = await this._ida.getIndex(superTokenNorm, publisherNorm, indexId);\n    return this.constructor._sanitizeIndexData(result);\n  }\n  /**\n   * @dev List indices of a publisher\n   * @param {tokenParam} superToken SuperToken for the index\n   * @param {addressParam} publisher Publisher of the index\n   * @return {Promise<Subscription>} Subscription data\n   */\n\n\n  async listIndices(_ref11) {\n    let {\n      superToken,\n      publisher\n    } = _ref11;\n    const superTokenNorm = await this._sf.utils.normalizeTokenParam(superToken);\n    const publisherNorm = await this._sf.utils.normalizeAddressParam(publisher); // TODO ethers support\n\n    return (await this._ida.getPastEvents(\"IndexCreated\", {\n      fromBlock: 0,\n      toBlock: \"latest\",\n      filter: {\n        token: superTokenNorm,\n        publisher: publisherNorm\n      }\n    })).map(e => Number(e.args.indexId.toString()));\n  }\n  /**\n   * @dev List subscribers of an index\n   * @param {tokenParam} superToken SuperToken for the index\n   * @param {addressParam} publisher Publisher of the index\n   * @param {int} indexId ID of the index\n   * @return {Promise<Subscription>} Subscription data\n   */\n\n\n  async listSubcribers(_ref12) {\n    let {\n      superToken,\n      publisher,\n      indexId\n    } = _ref12;\n    const superTokenNorm = await this._sf.utils.normalizeTokenParam(superToken);\n    const publisherNorm = await this._sf.utils.normalizeAddressParam(publisher);\n    let updates;\n    updates = await this._ida.getPastEvents(\"IndexUnitsUpdated\", {\n      fromBlock: 0,\n      toBlock: \"latest\",\n      filter: {\n        token: superTokenNorm,\n        publisher: publisherNorm,\n        indexId\n      }\n    }); // TODO ethers support\n\n    return Object.values(updates.reduce((acc, i) => {\n      acc[i.args.subscriber] = i;\n      return acc;\n    }, {})).filter(i => i.args.units.toString() != \"0\").map(i => ({\n      subscriber: i.args.subscriber,\n      units: i.args.units.toString()\n    }));\n  }\n  /**\n   * @dev List subscriptions of an account\n   * @param {tokenParam} superToken SuperToken for the index\n   * @param {addressParam} publisher Publisher of the index\n   * @param {int} indexId ID of the index\n   * @return {Promise<Subscription>} Subscription data\n   */\n\n\n  async listSubscriptions(_ref13) {\n    let {\n      superToken,\n      subscriber\n    } = _ref13;\n    const superTokenNorm = await this._sf.utils.normalizeTokenParam(superToken);\n    const subscriberNorm = await this._sf.utils.normalizeAddressParam(subscriber);\n    const result = await this._ida.listSubscriptions(superTokenNorm, subscriberNorm);\n    return this.constructor._sanitizeSubscriptionInfo(result);\n  }\n\n  static _sanitizeIndexData(_ref14) {\n    let {\n      exist,\n      indexValue,\n      totalUnitsApproved,\n      totalUnitsPending\n    } = _ref14;\n    return {\n      exist,\n      indexValue: indexValue.toString(),\n      totalUnitsApproved: totalUnitsApproved.toString(),\n      totalUnitsPending: totalUnitsPending.toString()\n    };\n  }\n\n  static _sanitizeSubscriptionData(_ref15) {\n    let {\n      exist,\n      approved,\n      units,\n      pendingDistribution\n    } = _ref15;\n    return {\n      exist,\n      approved,\n      units: units.toString(),\n      pendingDistribution: pendingDistribution.toString()\n    };\n  }\n\n  static _sanitizeSubscriptionInfo(_ref16) {\n    let {\n      publishers,\n      indexIds,\n      unitsList\n    } = _ref16;\n    return publishers.map((publisher, i) => ({\n      publisher,\n      indexId: Number(indexIds[i].toString()),\n      units: unitsList[i].toString()\n    }));\n  }\n\n};","map":null,"metadata":{},"sourceType":"script"}