{"ast":null,"code":"import { stringify } from '../../../utils/stringify.js';\nimport { array } from '../../array.js';\nimport { frequency } from '../../frequency.js';\nimport { oneof } from '../../oneof.js';\nimport { set } from '../../set.js';\nimport { tuple } from '../../tuple.js';\nimport { bigInt } from '../../bigInt.js';\nimport { date } from '../../date.js';\nimport { float32Array } from '../../float32Array.js';\nimport { float64Array } from '../../float64Array.js';\nimport { int16Array } from '../../int16Array.js';\nimport { int32Array } from '../../int32Array.js';\nimport { int8Array } from '../../int8Array.js';\nimport { uint16Array } from '../../uint16Array.js';\nimport { uint32Array } from '../../uint32Array.js';\nimport { uint8Array } from '../../uint8Array.js';\nimport { uint8ClampedArray } from '../../uint8ClampedArray.js';\nimport { sparseArray } from '../../sparseArray.js';\nimport { keyValuePairsToObjectMapper, keyValuePairsToObjectUnmapper } from '../mappers/KeyValuePairsToObject.js';\nimport { convertFromNext, convertToNext } from '../../../check/arbitrary/definition/Converters.js';\nimport { arrayToMapMapper, arrayToMapUnmapper } from '../mappers/ArrayToMap.js';\nimport { arrayToSetMapper, arrayToSetUnmapper } from '../mappers/ArrayToSet.js';\nimport { objectToPrototypeLessMapper, objectToPrototypeLessUnmapper } from '../mappers/ObjectToPrototypeLess.js';\nimport { letrec } from '../../letrec.js';\n\nfunction entriesOf(keyArb, valueArb, maxKeys) {\n  return convertToNext(set(tuple(keyArb, valueArb), {\n    maxLength: maxKeys,\n    compare: (t1, t2) => t1[0] === t2[0]\n  }));\n}\n\nfunction mapOf(ka, va, maxKeys) {\n  return convertFromNext(entriesOf(ka, va, maxKeys).map(arrayToMapMapper, arrayToMapUnmapper));\n}\n\nfunction dictOf(ka, va, maxKeys) {\n  return convertFromNext(entriesOf(ka, va, maxKeys).map(keyValuePairsToObjectMapper, keyValuePairsToObjectUnmapper));\n}\n\nfunction setOf(va, maxKeys) {\n  return convertFromNext(convertToNext(set(va, {\n    maxLength: maxKeys\n  })).map(arrayToSetMapper, arrayToSetUnmapper));\n}\n\nfunction prototypeLessOf(objectArb) {\n  return convertFromNext(convertToNext(objectArb).map(objectToPrototypeLessMapper, objectToPrototypeLessUnmapper));\n}\n\nfunction typedArray() {\n  return oneof(int8Array(), uint8Array(), uint8ClampedArray(), int16Array(), uint16Array(), int32Array(), uint32Array(), float32Array(), float64Array());\n}\n\nexport function anyArbitraryBuilder(constraints) {\n  const arbitrariesForBase = constraints.values;\n  const maxDepth = constraints.maxDepth;\n  const maxKeys = constraints.maxKeys;\n  const baseArb = oneof(...arbitrariesForBase);\n  return letrec(tie => ({\n    anything: oneof({\n      maxDepth\n    }, baseArb, tie('array'), tie('object'), ...(constraints.withMap ? [tie('map')] : []), ...(constraints.withSet ? [tie('set')] : []), ...(constraints.withObjectString ? [tie('anything').map(o => stringify(o))] : []), ...(constraints.withNullPrototype ? [prototypeLessOf(tie('object'))] : []), ...(constraints.withBigInt ? [bigInt()] : []), ...(constraints.withDate ? [date()] : []), ...(constraints.withTypedArray ? [typedArray()] : []), ...(constraints.withSparseArray ? [sparseArray(tie('anything'), {\n      maxNumElements: maxKeys\n    })] : [])),\n    keys: constraints.withObjectString ? frequency({\n      arbitrary: constraints.key,\n      weight: 10\n    }, {\n      arbitrary: tie('anything').map(o => stringify(o)),\n      weight: 1\n    }) : constraints.key,\n    arrayBase: oneof(...arbitrariesForBase.map(arb => array(arb, {\n      maxLength: maxKeys\n    }))),\n    array: oneof(tie('arrayBase'), array(tie('anything'), {\n      maxLength: maxKeys\n    })),\n    setBase: oneof(...arbitrariesForBase.map(arb => setOf(arb, maxKeys))),\n    set: oneof(tie('setBase'), setOf(tie('anything'), maxKeys)),\n    mapBase: oneof(...arbitrariesForBase.map(arb => mapOf(tie('keys'), arb, maxKeys))),\n    map: oneof(tie('mapBase'), oneof(mapOf(tie('keys'), tie('anything'), maxKeys), mapOf(tie('anything'), tie('anything'), maxKeys))),\n    objectBase: oneof(...arbitrariesForBase.map(arb => dictOf(tie('keys'), arb, maxKeys))),\n    object: oneof(tie('objectBase'), dictOf(tie('keys'), tie('anything'), maxKeys))\n  })).anything;\n}","map":null,"metadata":{},"sourceType":"module"}