{"ast":null,"code":"import { convertFromNext, convertToNext } from '../check/arbitrary/definition/Converters.js';\nimport { array } from './array.js';\nimport { base64 } from './base64.js';\nimport { maxLengthFromMinLength } from './_internals/helpers/MaxLengthFromMinLength.js';\nimport { extractStringConstraints } from './_internals/helpers/StringConstraintsExtractor.js';\nimport { codePointsToStringMapper, codePointsToStringUnmapper } from './_internals/mappers/CodePointsToString.js';\nimport { stringToBase64Mapper, stringToBase64Unmapper } from './_internals/mappers/StringToBase64.js';\n\nfunction extractMinMaxConstraints(args) {\n  const constraints = extractStringConstraints(args);\n  const minLength = constraints.minLength !== undefined ? constraints.minLength : 0;\n  const maxLength = constraints.maxLength !== undefined ? constraints.maxLength : maxLengthFromMinLength(minLength);\n  return {\n    minLength,\n    maxLength\n  };\n}\n\nfunction base64String() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  const constraints = extractMinMaxConstraints(args);\n  const unscaledMinLength = constraints.minLength;\n  const unscaledMaxLength = constraints.maxLength;\n  const minLength = unscaledMinLength + 3 - (unscaledMinLength + 3) % 4;\n  const maxLength = unscaledMaxLength - unscaledMaxLength % 4;\n  if (minLength > maxLength) throw new Error('Minimal length should be inferior or equal to maximal length');\n  if (minLength % 4 !== 0) throw new Error('Minimal length of base64 strings must be a multiple of 4');\n  if (maxLength % 4 !== 0) throw new Error('Maximal length of base64 strings must be a multiple of 4');\n  return convertFromNext(convertToNext(array(base64(), {\n    minLength,\n    maxLength\n  })).map(codePointsToStringMapper, codePointsToStringUnmapper).map(stringToBase64Mapper, stringToBase64Unmapper));\n}\n\nexport { base64String };","map":null,"metadata":{},"sourceType":"module"}