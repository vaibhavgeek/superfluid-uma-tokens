{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.nativizeEventArgs = exports.nativizeReturn = exports.nativize = exports.unsafeNativize = exports.ResultInspector = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:export\");\n\nconst Conversion = __importStar(require(\"./conversion\"));\n\nconst inspect_1 = require(\"./format/utils/inspect\");\n\nObject.defineProperty(exports, \"ResultInspector\", {\n  enumerable: true,\n  get: function () {\n    return inspect_1.ResultInspector;\n  }\n});\nObject.defineProperty(exports, \"unsafeNativize\", {\n  enumerable: true,\n  get: function () {\n    return inspect_1.unsafeNativize;\n  }\n});\n/**\n * This function is similar to\n * [[Format.Utils.Inspect.unsafeNativize|unsafeNativize]], but is intended to\n * be safe, and also allows for different output formats.  The only currently\n * supported format is \"ethers\", which is intended to match the way that\n * Truffle Contract currently returns values (based on the Ethers decoder).  As\n * such, it only handles ABI types, and in addition does not handle the types\n * fixed, ufixed, or function.  Note that in these cases it returns `undefined`\n * rather than throwing, as we want this function to be used in contexts where\n * it had better not throw.  It also does not handle circularities, for similar\n * reasons.\n *\n * To handle numeric types, this function takes an optional numberFormatter\n * option that tells it how to handle numbers; this function should take a\n * BigInt as input.  By default, this function will be the identity, and so\n * numbers will be represented as BigInts.\n *\n * Note that this function begins by calling abify, so out-of-range enums (that\n * aren't so out-of-range as to be padding errors) will not return `undefined`.\n * Out-of-range booleans similarly will return true rather than `undefined`.\n * However, other range errors may return `undefined`; this may technically be a\n * slight incompatibility with existing behavior, but should not be relevant\n * except in quite unusual cases.\n *\n * In order to match the behavior for tuples, tuples will be transformed into\n * arrays, but named entries will additionally be keyed by name.  Moreover,\n * indexed variables of reference type will be nativized to an undecoded hex\n * string.\n */\n\nfunction nativize(result) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  const numberFormatter = options.numberFormatter || (x => x);\n\n  const format = options.format || \"ethers\";\n\n  switch (format) {\n    case \"ethers\":\n      return ethersCompatibleNativize(result, numberFormatter);\n  }\n}\n\nexports.nativize = nativize;\n\nfunction ethersCompatibleNativize(result) {\n  let numberFormatter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x => x;\n\n  //note: the original version of this function began by calling abify,\n  //but we don't do that here because abify requires a userDefinedTypes\n  //parameter and we don't want that.\n  //However, it only needs that to handle getting the types right.  Since\n  //we don't care about that here, we instead do away with abify and handle\n  //such matters ourselves (which is less convenient, yeah).\n  switch (result.kind) {\n    case \"error\":\n      switch (result.error.kind) {\n        case \"IndexedReferenceTypeError\":\n          //strictly speaking for arrays ethers will fail to decode\n          //rather than do this, but, eh\n          return result.error.raw;\n\n        case \"EnumOutOfRangeError\":\n          return numberFormatter(Conversion.toBigInt(result.error.rawAsBN));\n\n        default:\n          return undefined;\n      }\n\n    case \"value\":\n      switch (result.type.typeClass) {\n        case \"uint\":\n        case \"int\":\n          const asBN = result.value.asBN;\n          return numberFormatter(Conversion.toBigInt(asBN));\n\n        case \"enum\":\n          const numericAsBN = result.value.numericAsBN;\n          return numberFormatter(Conversion.toBigInt(numericAsBN));\n\n        case \"bool\":\n          return result.value.asBoolean;\n\n        case \"bytes\":\n          const asHex = result.value.asHex;\n          return asHex !== \"0x\" ? asHex : null;\n\n        case \"address\":\n          return result.value.asAddress;\n\n        case \"contract\":\n          return result.value.address;\n\n        case \"string\":\n          {\n            const coercedResult = result;\n\n            switch (coercedResult.value.kind) {\n              case \"valid\":\n                return coercedResult.value.asString;\n\n              case \"malformed\":\n                // this will turn malformed utf-8 into replacement characters (U+FFFD) (WARNING)\n                // note we need to cut off the 0x prefix\n                return Buffer.from(coercedResult.value.asHex.slice(2), \"hex\").toString();\n            }\n          }\n\n        case \"userDefinedValueType\":\n          return ethersCompatibleNativize(result.value, numberFormatter);\n\n        case \"array\":\n          return result.value.map(value => ethersCompatibleNativize(value, numberFormatter));\n\n        case \"tuple\":\n        case \"struct\":\n          //in this case, we need the result to be an array, but also\n          //to have the field names (where extant) as keys\n          const nativized = [];\n          const pairs = result.value;\n\n          for (const {\n            name,\n            value\n          } of pairs) {\n            const nativizedValue = ethersCompatibleNativize(value, numberFormatter);\n            nativized.push(nativizedValue);\n\n            if (name) {\n              nativized[name] = nativizedValue;\n            }\n          }\n\n          return nativized;\n\n        case \"function\":\n          switch (result.type.visibility) {\n            case \"external\":\n              const coercedResult = result; //ethers per se doesn't handle this, but web3's hacked version will\n              //sometimes decode these as just a bytes24, so let's do that\n\n              return coercedResult.value.contract.address.toLowerCase() + coercedResult.value.selector.slice(2);\n\n            case \"internal\":\n              return undefined;\n          }\n\n        case \"fixed\":\n        case \"ufixed\":\n        default:\n          return undefined;\n      }\n\n  }\n}\n/**\n * This function is similar to [[nativize]], but takes\n * a [[ReturndataDecoding]].  If there's only one returned value, it\n * will be run through compatibleNativize but otherwise unaltered;\n * otherwise the results will be put in an object.\n *\n * Note that if the ReturndataDecoding is not a [[ReturnDecoding]],\n * this will just return `undefined`.\n */\n\n\nfunction nativizeReturn(decoding) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  const numberFormatter = options.numberFormatter || (x => x);\n\n  const format = options.format || \"ethers\";\n\n  switch (format) {\n    case \"ethers\":\n      return ethersCompatibleNativizeReturn(decoding, numberFormatter);\n  }\n}\n\nexports.nativizeReturn = nativizeReturn;\n\nfunction ethersCompatibleNativizeReturn(decoding) {\n  let numberFormatter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x => x;\n\n  if (decoding.kind !== \"return\") {\n    return undefined;\n  }\n\n  if (decoding.arguments.length === 1) {\n    return ethersCompatibleNativize(decoding.arguments[0].value, numberFormatter);\n  }\n\n  const result = {};\n\n  for (let i = 0; i < decoding.arguments.length; i++) {\n    const {\n      name,\n      value\n    } = decoding.arguments[i];\n    const nativized = ethersCompatibleNativize(value, numberFormatter);\n    result[i] = nativized;\n\n    if (name) {\n      result[name] = nativized;\n    }\n  }\n\n  return result;\n}\n/**\n * This function is similar to [[compatibleNativize]], but takes\n * a [[LogDecoding]], and puts the results in an object.  Note\n * that this does not return the entire event info, but just the\n * `args` for the event.\n */\n\n\nfunction nativizeEventArgs(decoding) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  const numberFormatter = options.numberFormatter || (x => x);\n\n  const format = options.format || \"ethers\";\n\n  switch (format) {\n    case \"ethers\":\n      return ethersCompatibleNativizeEventArgs(decoding, numberFormatter);\n  }\n}\n\nexports.nativizeEventArgs = nativizeEventArgs;\n\nfunction ethersCompatibleNativizeEventArgs(decoding) {\n  let numberFormatter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x => x;\n  const result = {};\n\n  for (let i = 0; i < decoding.arguments.length; i++) {\n    const {\n      name,\n      value\n    } = decoding.arguments[i];\n    const nativized = ethersCompatibleNativize(value, numberFormatter);\n    result[i] = nativized;\n\n    if (name) {\n      result[name] = nativized;\n    }\n  } //note: if you have an argument named __length__, what ethers\n  //actually does is... weird.  we're just going to do this instead,\n  //which is simpler and probably more useful, even if it's not strictly\n  //the same (I *seriously* doubt anyone was relying on the old behavior,\n  //because it's, uh, not very useful)\n\n\n  result.__length__ = decoding.arguments.length;\n  return result;\n}","map":null,"metadata":{},"sourceType":"script"}