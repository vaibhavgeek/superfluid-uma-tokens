{"ast":null,"code":"import { integer } from '../integer.js';\nimport { floatToIndex, indexToFloat, MAX_VALUE_32 } from '../_internals/helpers/FloatHelpers.js';\nimport { convertFromNext, convertToNext } from '../../check/arbitrary/definition/Converters.js';\n\nfunction safeFloatToIndex(f, constraintsLabel) {\n  const conversionTrick = 'you can convert any double to a 32-bit float by using `new Float32Array([myDouble])[0]`';\n  const errorMessage = 'fc.floatNext constraints.' + constraintsLabel + ' must be a 32-bit float - ' + conversionTrick;\n\n  if (Number.isNaN(f) || Number.isFinite(f) && (f < -MAX_VALUE_32 || f > MAX_VALUE_32)) {\n    throw new Error(errorMessage);\n  }\n\n  const index = floatToIndex(f);\n\n  if (!Number.isInteger(index)) {\n    throw new Error(errorMessage);\n  }\n\n  return index;\n}\n\nfunction unmapperFloatToIndex(value) {\n  if (typeof value !== 'number') throw new Error('Unsupported type');\n  return floatToIndex(value);\n}\n\nexport function floatNext() {\n  let constraints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    noDefaultInfinity = false,\n    noNaN = false,\n    min = noDefaultInfinity ? -MAX_VALUE_32 : Number.NEGATIVE_INFINITY,\n    max = noDefaultInfinity ? MAX_VALUE_32 : Number.POSITIVE_INFINITY\n  } = constraints;\n  const minIndex = safeFloatToIndex(min, 'min');\n  const maxIndex = safeFloatToIndex(max, 'max');\n\n  if (minIndex > maxIndex) {\n    throw new Error('fc.floatNext constraints.min must be smaller or equal to constraints.max');\n  }\n\n  if (noNaN) {\n    return convertFromNext(convertToNext(integer({\n      min: minIndex,\n      max: maxIndex\n    })).map(indexToFloat, unmapperFloatToIndex));\n  }\n\n  const minIndexWithNaN = maxIndex > 0 ? minIndex : minIndex - 1;\n  const maxIndexWithNaN = maxIndex > 0 ? maxIndex + 1 : maxIndex;\n  return convertFromNext(convertToNext(integer({\n    min: minIndexWithNaN,\n    max: maxIndexWithNaN\n  })).map(index => {\n    if (index > maxIndex || index < minIndex) return Number.NaN;else return indexToFloat(index);\n  }, value => {\n    if (typeof value !== 'number') throw new Error('Unsupported type');\n    if (Number.isNaN(value)) return maxIndex !== maxIndexWithNaN ? maxIndexWithNaN : minIndexWithNaN;\n    return floatToIndex(value);\n  }));\n}","map":null,"metadata":{},"sourceType":"module"}