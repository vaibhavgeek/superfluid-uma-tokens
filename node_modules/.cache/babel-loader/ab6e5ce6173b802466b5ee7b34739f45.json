{"ast":null,"code":"const loadContracts = require(\"./loadContracts\");\n\nconst getConfig = require(\"./getConfig\");\n\nconst GasMeter = require(\"./utils/gasMetering/gasMetering\");\n\nconst {\n  getErrorResponse\n} = require(\"./utils/error\");\n\nconst {\n  isAddress,\n  validateAddress\n} = require(\"./utils/general\");\n\nconst {\n  batchCall\n} = require(\"./batchCall\");\n\nconst ConstantFlowAgreementV1Helper = require(\"./ConstantFlowAgreementV1Helper\");\n\nconst InstantDistributionAgreementV1Helper = require(\"./InstantDistributionAgreementV1Helper\");\n\nconst User = require(\"./User\");\n\nconst ZERO_ADDRESS = \"0x0000000000000000000000000000000000000000\";\n/**\n * @dev Superfluid Framework class\n */\n\nmodule.exports = class Framework {\n  /**\n   * @dev Create new Superfluid framework object\n   * @param {string} options.version (Default: v1) protocol release version.\n   * @param {boolean} options.isTruffle (Default: false) if the framework is used within truffle environment.\n   * @param {Web3} options.web3  Injected web3 instance (version has to be 1.x)\n   * @param {Ethers} options.ethers  Injected ethers instance\n   *\n   * @param {Array} options.additionalContracts (Optional) additional contracts to be loaded\n   * @param {string[]} options.tokens (Optional) Tokens to be loaded with a list of (in order of preference):\n   *    - super chain-native token symbol (see getConfig.js),\n   *    - underlying token resolver key (tokens.{KEY}),\n   *    - super token key  (supertokens.{protocol_release_version}.{KEY})\n   * @param {bool} options.loadSuperNativeToken Load super native token (e.g. ETHx) if possible\n   * @param {Function} options.contractLoader (Optional) alternative contract loader function\n   *\n   * @param {string} options.resolverAddress force resolver address\n   * @param {string} options.gasReportType output type for gas reporting. Currently HTML only\n   * @return {Framework} The Framework object\n   *\n   * NOTE: You should call async function Framework.initialize to initialize the object.\n   */\n  constructor(options) {\n    this._options = options;\n    this.version = options.version || \"v1\";\n    if (options.isTruffle && (options.ethers || options.web3)) throw Error(\"@superfluid-finance/js-sdk: Flag 'isTruffle' cannot be 'true' when using a web3/ethers instance.\");\n    if (!options.isTruffle && !options.ethers && !options.web3) throw Error(\"@superfluid-finance/js-sdk: You must provide a web3 or ethers instance.\");\n    if (options.ethers && options.web3) throw Error(`@superfluid-finance/js-sdk: You cannot provide both a web3 and ethers instance.\n                Please choose only one.`);\n    this.web3 = options.isTruffle ? global.web3 : options.web3;\n    this.ethers = options.ethers;\n\n    if (options.gasReportType) {\n      if (options.gasReportType !== \"HTML\" && options.gasReportType !== \"JSON\") {\n        throw new Error(\"Unsuported gas report type: \" + options.gasReportType);\n      }\n\n      console.debug(\"Enabling gas report type:\", options.gasReportType);\n      this._gasReportType = options.gasReportType;\n    }\n  }\n  /**\n   * @dev Initialize the framework object\n   * @return {Promise}\n   */\n\n\n  async initialize() {\n    console.log(\"Initializing Superfluid Framework...\");\n\n    if (this.ethers) {\n      const network = await this.ethers.getNetwork();\n      this.networkType = network.name;\n      this.networkId = network.chainId;\n    } else {\n      // NOTE: querying network type first,\n      // Somehow web3.eth.net.getId may send bogus number if this was not done first\n      // It could be a red-herring issue, but it makes it more stable.\n      this.networkType = await this.web3.eth.net.getNetworkType();\n      this.networkId = await this.web3.eth.net.getId(); // TODO use eth.getChainId;\n    }\n\n    console.log(\"networkType\", this.networkType);\n    console.log(\"networkId\", this.networkId);\n    this.config = getConfig(this.networkId);\n    this.contracts = await loadContracts({\n      isTruffle: this._options.isTruffle,\n      web3: this._options.web3,\n      ethers: this._options.ethers,\n      from: this._options.from,\n      additionalContracts: this._options.additionalContracts,\n      contractLoader: this._options.contractLoader,\n      networkId: this.networkId\n    });\n    const resolverAddress = this._options.resolverAddress || this.config.resolverAddress;\n    console.debug(\"Resolver at\", resolverAddress);\n    this.resolver = await this.contracts.IResolver.at(resolverAddress); // get framework loader and load\n\n    this.loader = await this.contracts.SuperfluidLoader.at(await this.resolver.get(\"SuperfluidLoader-v1\"));\n    console.debug(\"Superfluid Loader v1\", this.loader.address);\n    console.debug(\"Loading framework with release version\", this.version);\n    const loaderResult = await this.loader.loadFramework(this.version);\n    console.debug(\"Superfluid host contract: TruffleContract .host\", loaderResult.superfluid);\n    console.debug(\"SuperTokenFactory address:\", loaderResult.superTokenFactory);\n    console.debug(\"ConstantFlowAgreementV1: TruffleContract .agreements.cfa | Helper .cfa\", loaderResult.agreementCFAv1);\n    console.debug(\"InstantDistributionAgreementV1: TruffleContract .agreements.ida | Helper .ida\", loaderResult.agreementIDAv1);\n    this.agreements = {};\n    this.tokens = {};\n    this.superTokens = {}; // load agreement classes\n\n    [this.host, this.agreements.cfa, this.agreements.ida] = await Promise.all([// load host\n    this.contracts.ISuperfluid.at(loaderResult.superfluid), // load agreements\n    this.contracts.IConstantFlowAgreementV1.at(loaderResult.agreementCFAv1), this.contracts.IInstantDistributionAgreementV1.at(loaderResult.agreementIDAv1), // load tokens\n    ...[...(this._options.tokens ? this._options.tokens : []), ...(this._options.loadSuperNativeToken && this.config.nativeTokenSymbol ? [this.config.nativeTokenSymbol] : [])].map(this.loadToken.bind(this))]); // load agreement helpers\n\n    this.cfa = new ConstantFlowAgreementV1Helper(this);\n    this.ida = new InstantDistributionAgreementV1Helper(this);\n    this.utils = new (require(\"./Utils\"))(this);\n\n    if (this._gasReportType) {\n      const defaultGasPrice = await this.web3.eth.getGasPrice();\n      this._gasMetering = new GasMeter(this.web3, this._gasReportType, defaultGasPrice);\n    }\n\n    console.log(\"Superfluid Framework initialized.\");\n  }\n  /**\n   * @dev Load additional token using resolver\n   * @param {String} superTokenKey super token key used to query resolver\n   */\n\n\n  async isSuperTokenListed(superTokenKey) {\n    if (!isAddress(superTokenKey)) {\n      const superTokenAddress = await this.resolver.get(`supertokens.${this.version}.${superTokenKey}`);\n      return superTokenAddress !== ZERO_ADDRESS;\n    } else {\n      try {\n        const superToken = await this.contracts.ISuperToken.at(superTokenKey);\n        const symbol = await superToken.symbol();\n        const superTokenAddress = await this.resolver.get(`supertokens.${this.version}.${symbol}`);\n        return superToken.address.toLowerCase() == superTokenAddress.toLowerCase();\n      } catch (error) {\n        console.warn(\"Invalid super token address\", superTokenKey);\n        return false;\n      }\n    }\n  }\n  /**\n   * @dev Load additional token using resolver\n   * @param {String} tokenKey token key used to query resolver (in order of preference):\n   *    - super chain-native token symbol (see getConfig.js),\n   *    - underlying token resolver key (tokens.{KEY}),\n   *    - super token key (supertokens.{protocol_release_version}.{KEY})\n   *    - super token address\n   *\n   * As a result:\n   * - sf.tokens[tokenKey] and sf.superTokens[tokenKey] is the loaded SuperToken Object.\n   * - Additionally, superTokenObject.underlyingToken is the underlying token object.\n   * - If tokenKey is a super token address, it is normalized to lower case.\n   */\n\n\n  async loadToken(tokenKey) {\n    let underlyingToken;\n    let superTokenKey;\n    let superTokenContractType;\n    let superTokenAddress;\n    let superToken;\n    let superTokenCustomType = \"\"; // validate if the underlying token matches its corresponding\n    // listed super token underlying token\n\n    let doValidateUnderlyingToken = false;\n    let isLoadingByAddress = false;\n\n    if (!isAddress(tokenKey)) {\n      if (tokenKey === this.config.nativeTokenSymbol || tokenKey === this.config.nativeTokenSymbol + \"x\") {\n        // it is the same as native token symbol (or plus \"x\"), we assume it is a SETH\n        superTokenKey = this.config.nativeTokenSymbol + \"x\";\n        superTokenContractType = this.contracts.ISETH;\n        superTokenCustomType = \"SETH\";\n      } else {\n        // first check if tokenKey is symbol of a listed non-super token\n        const tokenAddress = await this.resolver.get(`tokens.${tokenKey}`);\n\n        if (tokenAddress !== ZERO_ADDRESS) {\n          // if it is, we assume its ERC20 super token wrapper is postfixed with \"x\"\n          underlyingToken = await this.contracts.ERC20WithTokenInfo.at(tokenAddress);\n          this.tokens[tokenKey] = underlyingToken;\n          console.debug(`${tokenKey}: ERC20WithTokenInfo .tokens[\"${tokenKey}\"]`, tokenAddress);\n          superTokenKey = tokenKey + \"x\";\n          doValidateUnderlyingToken = true;\n        } else {\n          // if it is not, then we assume it is a listed super token\n          superTokenKey = tokenKey;\n        }\n\n        superTokenContractType = this.contracts.ISuperToken;\n      } // load super token\n\n\n      superTokenAddress = await this.resolver.get(`supertokens.${this.version}.${superTokenKey}`);\n\n      if (superTokenAddress === ZERO_ADDRESS) {\n        throw new Error(`Super Token for ${tokenKey} cannot be found`);\n      }\n    } else {\n      superTokenAddress = superTokenKey = tokenKey.toLowerCase();\n      superTokenContractType = this.contracts.ISuperToken;\n      isLoadingByAddress = true;\n    }\n\n    superToken = await superTokenContractType.at(superTokenAddress);\n    superToken.superTokenCustomType = superTokenCustomType;\n    this.tokens[superTokenKey] = superToken;\n    this.superTokens[superTokenKey] = superToken;\n    let underlyingTokenAddress = await superToken.getUnderlyingToken.call();\n\n    if (doValidateUnderlyingToken) {\n      if (underlyingTokenAddress !== ZERO_ADDRESS) {\n        // if underlying token is not undefined and not equal to getUnderlyingToken() returned address\n        if (underlyingTokenAddress.toLowerCase() !== underlyingToken.address.toLowerCase()) {\n          throw new Error(`Underlying token addresses are different for ${tokenKey}`);\n        }\n      } else {\n        throw new Error(`Unexpected underlying token for ${tokenKey}`);\n      }\n    } // if underlying token is still null or undefined, load it\n\n\n    if (!underlyingToken) {\n      if (underlyingTokenAddress !== ZERO_ADDRESS) {\n        underlyingToken = await this.contracts.ERC20WithTokenInfo.at(underlyingTokenAddress);\n\n        if (!isLoadingByAddress) {\n          // do not pollute the tokens namespace if loading a potentially\n          // unlisted token\n          const symbol = await underlyingToken.symbol();\n          this.tokens[symbol] = underlyingToken;\n        }\n      }\n    }\n\n    superToken.underlyingToken = underlyingToken;\n    console.debug(`${superTokenKey}: ISuperToken .tokens[\"${superTokenKey}\"] ${superTokenCustomType}`, superToken.address);\n  }\n  /**\n   * @dev Create the ERC20 wrapper from underlying token\n   * @param {Any} tokenInfo the TokenInfo contract object to the underlying token\n   * @param {string} superTokenName (optional) overriding superTokenName\n   * @param {string} superTokenSymbol (optional) overriding superTokenSymbol\n   * @param {address} from (optional) send transaction from\n   * @param {address} upgradability (optional) send transaction from\n   * @return {Promise<Transaction>} web3 transaction object\n   */\n\n\n  async createERC20Wrapper(tokenInfo) {\n    let {\n      superTokenSymbol,\n      superTokenName,\n      from,\n      upgradability\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const tokenName = await tokenInfo.name.call();\n    const tokenSymbol = await tokenInfo.symbol.call();\n    superTokenName = superTokenName || `Super ${tokenName}`;\n    superTokenSymbol = superTokenSymbol || `${tokenSymbol}x`;\n    const factory = await this.contracts.ISuperTokenFactory.at(await this.host.getSuperTokenFactory());\n    upgradability = typeof upgradability === \"undefined\" ? 1 : upgradability;\n    const tx = await factory.createERC20Wrapper(tokenInfo.address, upgradability, superTokenName, superTokenSymbol, ...(from && [{\n      from\n    }] || []) // don't mind this silly js stuff, thanks to web3.js\n    );\n\n    this._pushTxForGasReport(tx, \"createERC20Wrapper\");\n\n    const wrapperAddress = tx.logs[0].args.token;\n    const u = [\"Non upgradable\", \"Semi upgrdable\", \"Full upgradable\"][upgradability];\n    console.log(`${u} super token ${superTokenSymbol} created at ${wrapperAddress}`);\n    const superToken = await this.contracts.ISuperToken.at(wrapperAddress);\n    superToken.tx = tx;\n    return superToken;\n  }\n\n  user(_ref) {\n    let {\n      address,\n      token,\n      options\n    } = _ref;\n\n    try {\n      if (!address) throw \"Please provide an address\";\n      if (!token) throw \"Please provide a token\";\n      validateAddress(address); // TODO: validate token\n\n      return new User({\n        sf: this,\n        address,\n        token,\n        options\n      });\n    } catch (e) {\n      throw getErrorResponse(e, \"Framework\", \"user\");\n    }\n  }\n\n  batchCall(calls) {\n    return this.host.batchCall(batchCall(calls));\n  }\n  /**\n   * @dev call to add a tx in the gas report. Does nothing if gas report type is not set.\n   * @param {tx oject} tx as returned by truffleContract action\n   * @param {str} actionName action title for row in report\n   */\n\n\n  _pushTxForGasReport(tx, actionName) {\n    this._gasMetering ? this._gasMetering.pushTx(tx, actionName) : null;\n  }\n  /**\n   * @dev generate gas report with transactions pushed until this call\n   * @param {str} name file name for gas report\n   * @throws if gas report type was not indicated in constructor\n   */\n\n\n  generateGasReport(name) {\n    if (!this._gasMetering) {\n      throw new Error(\"No gas metering configured\");\n    }\n\n    this._gasMetering.generateReport(name);\n  }\n\n};","map":null,"metadata":{},"sourceType":"script"}